<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Verb Group Checker | 日本語動詞グループ分類</title>

    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAV1BMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8usRReAAAAHHRSTlMAAQIDBAUGBwgJCgsMDQ4QERITFBUWFxgZGhscHR4fIA+ebpgAAABkSURBVBjTY2AAAkYGBgYEBkZGQmBhZGBkYGBgUFpaWlhYWlrZGRsbCxsfH29jZ29vf2DBQ0EBAwMDBAYGBgYGBnY3BQUFBQaYGRlYGBkYGFkYGRhYWBgYWBkZGJgYWBjYBQA4aRJshPCC0QAAAABJRU5ErkJggg==" />

    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">

    <style>
        /* ---------- 基本カラー & タイポ ---------- */
        :root {
            --font-body: 'Noto Sans JP',sans-serif;
            --surface: #fff;
            --surface-alt: #f5f7fa;
            --border: #d1d5db;
            --text: #111827;
            --muted: #4b5563;
            --brand: #0284c7;
            --brand-dark: #03689c;
            --g1: #FFDDB9;
            --g1-dark: #FF9E4E;
            --g2: #B9E6FF;
            --g2-dark: #3BA5E6;
            --g3: #E8C9FF;
            --g3-dark: #B253FF;
        }

        *, *::before, *::after {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font: 17px/1.7 var(--font-body);
            background: var(--surface-alt);
            color: var(--text);
        }

        /* ---------- コンテナ ---------- */
        .wrap {
            max-width: 760px;
            margin: clamp(1rem,4vw,2rem) auto;
            background: var(--surface);
            padding: clamp(1.25rem,4vw,2.5rem);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,.05)
        }

        h1 {
            margin: 0 0 .6em;
            text-align: center;
            font-size: clamp(1.6rem,2.3vw,2.2rem);
            color: var(--brand-dark)
        }

        h2 {
            font-size: 1.1rem;
            color: var(--muted);
            margin: 0 0 .8rem;
        }


        /* ---------- 入力エリア ---------- */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: .8rem
        }

        #verb {
            flex: 1 1 240px;
            padding: .75rem 1rem;
            border: 1px solid var(--border);
            border-radius: 12px;
            font-size: 1rem
        }

            #verb:focus {
                outline: none;
                border-color: var(--brand);
                box-shadow: 0 0 0 3px rgba(2,132,199,.25)
            }

        #run {
            padding: .8rem 1.2rem;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            background: var(--brand);
            color: #fff;
            cursor: pointer
        }

            #run:hover {
                background: var(--brand-dark)
            }

            #run:disabled, #verb:disabled {
                opacity: .6;
                cursor: not-allowed
            }

        /* ---------- 候補チップ ---------- */
        #candidates {
            margin: .6rem 0;
            display: flex;
            flex-wrap: wrap;
            gap: .5rem
        }

        .chip {
            background: var(--surface-alt);
            padding: .35rem .7rem;
            border-radius: 12px;
            border: 1px solid var(--border);
            cursor: pointer;
            user-select: none
        }

            .chip:hover {
                background: #eef2f7
            }

        /* ---------- 結果カード ---------- */
        .card {
            position: relative;
            margin-block: .8rem;
            border-radius: 12px;
            padding: 1rem 1.2rem 1.3rem;
            display: flex;
            gap: .8rem;
            box-shadow: 0 2px 6px rgba(0,0,0,.08)
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .is-animated {
            animation: fadeInUp 0.5s ease-out forwards;
        }

        .badge {
            width: 2.2rem;
            height: 2.2rem;
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: 700;
            color: #fff;
        }

        .title {
            font-size: 1.25rem;
            font-weight: 700;
            margin: 0;
            white-space: nowrap
        }

        .icon {
            font-size: 1.35rem;
            margin-right: .25rem
        }

        .tbl {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            font-size: .95rem
        }

            .tbl th, .tbl td {
                border: 1px solid var(--border);
                padding: .55rem;
                text-align: left
            }

            .tbl th {
                background: var(--surface-alt);
                white-space: nowrap;
                width: 120px
            }

        /* ---------- ローダ ---------- */
        .loader {
            margin: 2rem auto;
            width: 46px;
            height: 46px;
            border: 6px solid #eef2f7;
            border-top: 6px solid var(--brand);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            display: none
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        /* ---------- カード色分け ---------- */
        .g1 {
            background: var(--g1);
            border-left: 6px solid var(--g1-dark)
        }

            .g1 .badge {
                background: var(--g1-dark)
            }

        .g2 {
            background: var(--g2);
            border-left: 6px solid var(--g2-dark)
        }

            .g2 .badge {
                background: var(--g2-dark)
            }

        .g3 {
            background: var(--g3);
            border-left: 6px solid var(--g3-dark)
        }

            .g3 .badge {
                background: var(--g3-dark)
            }

        /* ---------- モバイル ---------- */
        @media(max-width:600px) {
            .card {
                flex-direction: column
            }

            .badge {
                margin-bottom: .4rem
            }
        }

        .err {
            color: #c00;
            margin-top: .8rem;
            font-weight: 600;
        }

        /* ========== 履歴エリア ========== */
        #history-area {
            display: none;
            margin-top: 2.5rem;
            border-top: 1px solid var(--border);
            padding-top: 1.5rem;
        }

        #history-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            margin-bottom: 1.2rem;
        }

        .history-item {
            background: var(--surface-alt);
            padding: 0.4rem 0.8rem;
            border-radius: 12px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            user-select: none;
        }

            .history-item:hover {
                border-color: var(--brand);
                color: var(--brand-dark);
                background: #e7f6ff;
            }

        #clear-history {
            background: none;
            border: 1px solid var(--border);
            color: var(--muted);
            padding: 0.4rem 1rem;
            font-size: 0.85rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

            #clear-history:hover {
                background: #fef2f2;
                color: #c00;
                border-color: #fca5a5;
            }

        /* ========== フッター (追加) ========== */
        .footer-credit {
            text-align: center;
            margin-top: 2.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border);
            font-size: 0.85rem;
            color: var(--muted);
        }

            .footer-credit a {
                color: var(--muted);
                text-decoration: none;
            }

                .footer-credit a:hover {
                    text-decoration: underline;
                    color: var(--brand-dark);
                }
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Verb Group Checker</h1>
        <div class="controls">
            <input id="verb" placeholder="Example：しらべる / 行きます" autocomplete="off" />
            <button id="run">Check!!</button>
        </div>
        <div id="candidates"></div>
        <div id="loader" class="loader" aria-label="Loading…"></div>
        <div id="result"></div>

        <div id="history-area">
            <h2>History</h2>
            <div id="history-list"></div>
            <button id="clear-history">Clear History</button>
        </div>

        <footer class="footer-credit">
            <p>
                &copy; <span id="copyright-year"></span> Mamoru Yaegashi, Zhu Laboratory.
                Powered by <a href="https://github.com/takuyaa/kuromoji.js" target="_blank" rel="noopener noreferrer">kuromoji.js</a>.
            </p>
        </footer>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/build/kuromoji.js"></script>
    <script>
        /* ========== 0. ユーティリティ ========== */
        const KANJI = /[一-龥々〆ヵヶ]/;
        const kat2hir = s => s.replace(/[\u30a1-\u30f6]/g, m => String.fromCharCode(m.charCodeAt(0) - 0x60));
        function isVerb(w) {
            const t = tokenizer?.tokenize(w)?.[0];
            return t?.pos === '動詞';
        }

        /* ========== 1. 共有辞書(JSONBin)設定 ========== */
        const BIN_URL = '';
        const MASTER_KEY = '';
        let map = {};

        async function loadShared() {
            if (!BIN_URL) return;
            try {
                const j = await fetch(BIN_URL, { headers: { 'X-Master-Key': MASTER_KEY } }).then(r => r.json());
                map = j.record || {};
            } catch (e) { console.warn('shared load fail', e); }
        }
        function saveShared(reading, word) {
            if (!BIN_URL) return;
            map[reading] ??= [];
            if (!map[reading].includes(word)) map[reading].push(word);
            fetch(BIN_URL, {
                method: 'PUT', headers: { 'X-Master-Key': MASTER_KEY, 'Content-Type': 'application/json' },
                body: JSON.stringify(map)
            });
        }

        /* ========== 2. Google Transliterate API ========== */
        async function translitVerb(hira) {
            const url = `https://www.google.com/transliterate?langpair=ja-Hira|ja&text=${encodeURIComponent(hira)}`;
            try {
                const j = await fetch(url).then(r => r.json());
                return (j[0]?.[1] || []).filter(w => KANJI.test(w) && isVerb(w));
            } catch { return []; }
        }

        /* ========== 3. DOM 要素 ========== */
        const $ = {
            v: document.getElementById('verb'),
            btn: document.getElementById('run'),
            cand: document.getElementById('candidates'),
            res: document.getElementById('result'),
            load: document.getElementById('loader'),
            histArea: document.getElementById('history-area'),
            histList: document.getElementById('history-list'),
            clearHist: document.getElementById('clear-history')
        };

        /* ========== 4. kuromoji 初期化 ========== */
        let tokenizer;
        showLoader(true);
        loadShared().finally(() => {
            kuromoji.builder({
                dicPath: "https://cdn.jsdelivr.net/npm/kuromoji@0.1.2/dict/"
            }).build((err, t) => {
                if (err) { console.error(err); return; }
                tokenizer = t;
                showLoader(false);
            });
        });

        /* ========== 5. 入力イベント ========== */
        $.btn.onclick = analyze;
        $.v.onkeydown = e => { if (e.key === 'Enter') analyze(); };

        /* ========== 6. メイン関数 ========== */
        async function analyze() {
            const inp = $.v.value.trim();
            if (!inp || !tokenizer) return;

            // --- 1. UIの準備 ---
            setDisabled(true); showLoader(true);
            $.res.innerHTML = $.cand.innerHTML = '';

            try {
                let wordToAnalyze = inp;
                let candidates = new Set();

                // --- 2. 【新ロジック】ひらがな入力の場合、解析前に漢字候補を推測 ---
                // KANJI定数にマッチしない = ひらがな(・カタカナ)のみ
                if (!KANJI.test(inp)) {
                    // 内部辞書と外部APIから候補を生成
                    const internalCands = new Set(map[inp] || []);
                    const externalCands = new Set(await translitVerb(inp));
                    const allCands = new Set([...internalCands, ...externalCands]);
                    allCands.delete(inp); // 入力そのものは候補から除外

                    if (allCands.size > 0) {
                        candidates = allCands;
                        // 漢字候補の中から最初のものを最有力候補とする
                        const primaryCandidate = [...allCands].find(c => KANJI.test(c));
                        if (primaryCandidate) {
                            // 最有力候補を、実際の解析対象とする
                            wordToAnalyze = primaryCandidate;
                        }
                    }
                }

                // --- 3. 動詞の解析を実行 ---
                // まず推測した単語（または元の入力）で解析を試みる
                let tok = tokenizer.tokenize(wordToAnalyze).find(t => t.pos === '動詞');

                // もし推測した単語で解析が失敗した場合、元の入力で再試行する（フォールバック）
                if (!tok && wordToAnalyze !== inp) {
                    tok = tokenizer.tokenize(inp).find(t => t.pos === '動詞');
                }

                // それでも解析できない場合はエラー
                if (!tok) {
                    // ただし、候補が見つかっていればそれだけでも表示する
                    if (candidates.size > 0) showChips(candidates);
                    throw new Error('判定できませんでした');
                }

                // --- 4. 解析成功後の処理 ---
                const dict = tok.basic_form;
                const reading = kat2hir(tok.reading || dict);

                // 自己学習辞書を更新
                map[reading] ??= [];
                if (!map[reading].includes(dict)) {
                    map[reading].push(dict);
                    saveShared(reading, dict);
                }

                // 最終的な候補リストを整理
                // 解析結果から得られた同音異義語も候補に追加
                (map[reading] || []).forEach(c => candidates.add(c));
                // 解析結果の辞書形そのものも（漢字なら）追加
                if (KANJI.test(dict)) candidates.add(dict);

                // 最終結果に表示される単語や元の入力は候補チップから除外
                candidates.delete(inp);
                candidates.delete(dict);

                // 候補チップを表示
                if (candidates.size > 0) {
                    showChips(candidates);
                }

                // --- 5. 結果の描画 ---
                const cls = classify(dict);
                const conj = getConj(dict, cls.g);

                // 元の入力がひらがなかどうかで表示モードを切り替える
                const isHiraganaMode = !KANJI.test(inp);
                render(dict, cls, conj, isHiraganaMode); // 第4引数にフラグを渡す



            } catch (e) {
                // エラーを一元管理
                $.res.innerHTML = `<p class="err">${e.message || 'エラーが発生しました'}</p>`;
            } finally {
                // UIの状態を必ず元に戻す
                setDisabled(false); showLoader(false);
                $.v.focus();
            }
        }

        /* ========== 7. UI ヘルパ ========== */
        function showLoader(v) { $.load.style.display = v ? 'block' : 'none'; }
        function setDisabled(v) { $.v.disabled = $.btn.disabled = v; }
        function showChips(set) {
            $.cand.innerHTML = [...set].slice(0, 8)
                .map(w => `<span class="chip" onclick="runFromChip('${w}')">${w}</span>`).join('');
        }
        function runFromChip(word) {
            $.v.value = word;
            analyze();
        }

        /* ========== 8. 活用ロジック (六形対応) ========== */
        function classify(df) {
            if (df === '来る' || df === 'くる') return { g: 3, name: 'III', type: 'カ変', exp: '来る（カ変）' };
            if (df.endsWith('する')) return { g: 3, name: 'III', type: 'サ変', exp: '-する（サ変）' };
            const godanRu = new Set(['切る', '入る', '帰る', '走る', '知る', '要る', '滑る', '減る', '焦る', '蹴る', '照る', '参る', '混じる', '喋る', 'かじる', '握る']);
            if (godanRu.has(df)) return { g: 1, name: 'I', type: '五段', exp: '五段例外（～る）' };
            if (df.endsWith('る')) {
                const read = tokenizer.tokenize(df)[0]?.reading || '';
                const pre = kat2hir(read).slice(-2, -1);
                if ('いきしちにひみりぎじびぴ'.includes(pre)) return { g: 2, name: 'II', type: '上一段', exp: 'イ段＋る' };
                if ('えけせてねへめれげぜべぺ'.includes(pre)) return { g: 2, name: 'II', type: '下一段', exp: 'エ段＋る' };
            }
            return { g: 1, name: 'I', type: '五段', exp: '語尾活用が五段' };
        }
        function getConj(df, g) {
            const stem = df.slice(0, -1);
            if (df === '来る' || df === 'くる') return { dict: df, nai: '来ない', masu: '来ます', ba: '来れば', vol: '来よう', te: '来て' };
            if (df.endsWith('する')) {
                const s = df.slice(0, -2);
                return { dict: df, nai: s + 'しない', masu: s + 'します', ba: s + 'すれば', vol: s + 'しよう', te: s + 'して' };
            }
            if (g === 2) {
                return { dict: df, nai: stem + 'ない', masu: stem + 'ます', ba: stem + 'れば', vol: stem + 'よう', te: stem + 'て' };
            }
            const rule = { う: { m: 'い', w: 'わ', ba: 'え', vol: 'お', te: 'って' }, く: { m: 'き', w: 'か', ba: 'け', vol: 'こ', te: 'いて' }, ぐ: { m: 'ぎ', w: 'が', ba: 'げ', vol: 'ご', te: 'いで' }, す: { m: 'し', w: 'さ', ba: 'せ', vol: 'そ', te: 'して' }, つ: { m: 'ち', w: 'た', ba: 'て', vol: 'と', te: 'って' }, ぬ: { m: 'に', w: 'な', ba: 'ね', vol: 'の', te: 'んで' }, ぶ: { m: 'び', w: 'ば', ba: 'べ', vol: 'ぼ', te: 'んで' }, む: { m: 'み', w: 'ま', ba: 'め', vol: 'も', te: 'んで' }, る: { m: 'り', w: 'ら', ba: 'れ', vol: 'ろ', te: 'って' } }[df.slice(-1)];
            const teForm = (df === '行く') ? '行って' : stem + rule.te;
            return { dict: df, nai: stem + rule.w + 'ない', masu: stem + rule.m + 'ます', ba: stem + rule.ba + 'ば', vol: stem + rule.vol + 'う', te: teForm };
        }
        function render(df, cls, conj, isHiraganaMode) {
            const labels = {
                dict: '辞書形', nai: 'ない形', masu: 'ます形',
                ba: 'ば形', vol: '意向形', te: 'て形'
            };

            const displayTitle = isHiraganaMode ? kat2hir(tokenizer.tokenize(df)[0]?.reading || df) : df;

            const rows = Object.entries(conj)
                .map(([k, v]) => {
                    let displayValue = v;
                    if (isHiraganaMode) {
                        // ▼ ここから修正 ▼
                        // 活用形を構成する全てのトークンの読みを結合して、完全なひらがな表示にする
                        const tokens = tokenizer.tokenize(v);
                        const fullReading = tokens.map(token => token.reading).join('');
                        displayValue = kat2hir(fullReading || v);
                        // ▲ ここまで修正 ▲
                    }
                    return `<tr><th>${labels[k]}</th><td>${displayValue}</td></tr>`;
                }).join('');

            const badge = ['Ⅰ', 'Ⅱ', 'Ⅲ'][cls.g - 1];
            const icon = { 1: '', 2: '', 3: '' }[cls.g];

            $.res.innerHTML = `<div class="card g${cls.g} is-animated">
          <div class="badge">${badge}</div>
          <p class="title"><span class="icon" aria-label="${cls.type}">${icon}</span> ${displayTitle}</p>
          <table class="tbl">${rows}</table>
        </div>`;
        }

        /* ========== 9. 履歴機能 ========== */
        let history = [];
        const MAX_HISTORY = 20;

        function initHistory() {
            const storedHistory = localStorage.getItem('verbHistory');
            if (storedHistory) {
                history = JSON.parse(storedHistory);
            }
            renderHistory();
            $.clearHist.addEventListener('click', clearHistory);
        }

        function renderHistory() {
            if (history.length === 0) {
                $.histArea.style.display = 'none';
                return;
            }
            $.histArea.style.display = 'block';
            $.histList.innerHTML = history
                .map(word => `<span class="history-item" onclick="runFromHistory('${word}')">${word}</span>`)
                .join('');
        }

        function runFromHistory(word) {
            $.v.value = word;
            analyze();
        }

        function addHistory(word) {
            const existingIndex = history.indexOf(word);
            if (existingIndex > -1) {
                history.splice(existingIndex, 1);
            }
            history.unshift(word);
            if (history.length > MAX_HISTORY) {
                history.pop();
            }
            localStorage.setItem('verbHistory', JSON.stringify(history));
            renderHistory();
        }

        function clearHistory() {
            history = [];
            localStorage.removeItem('verbHistory');
            renderHistory();
        }

        // ▼ コピーライトの年を自動更新
        document.getElementById('copyright-year').textContent = new Date().getFullYear();
    </script>
</body>
</html>